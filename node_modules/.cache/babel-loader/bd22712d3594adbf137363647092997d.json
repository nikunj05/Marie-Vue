{"remainingRequest":"C:\\xampp\\htdocs\\booking-master\\node_modules\\babel-loader\\lib\\index.js!C:\\xampp\\htdocs\\booking-master\\node_modules\\vuetify\\lib\\util\\mergeData.js","dependencies":[{"path":"C:\\xampp\\htdocs\\booking-master\\node_modules\\vuetify\\lib\\util\\mergeData.js","mtime":499162500000},{"path":"C:\\xampp\\htdocs\\booking-master\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\xampp\\htdocs\\booking-master\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0IjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbSI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZSI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvciI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zcGxpdCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy50cmltIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvciI7CmltcG9ydCBfb2JqZWN0U3ByZWFkIGZyb20gIkM6XFx4YW1wcFxcaHRkb2NzXFxib29raW5nLW1hc3Rlclxcbm9kZV9tb2R1bGVzXFxAYmFiZWxcXHJ1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0U3ByZWFkMiI7CmltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tICJDOlxceGFtcHBcXGh0ZG9jc1xcYm9va2luZy1tYXN0ZXJcXG5vZGVfbW9kdWxlc1xcQGJhYmVsXFxydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXkiOwoKZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gInVuZGVmaW5lZCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gIm51bWJlciIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfQoKZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSAic3RyaW5nIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09ICJPYmplY3QiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSAiTWFwIiB8fCBuID09PSAiU2V0IikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSAiQXJndW1lbnRzIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH0KCmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfQoKaW1wb3J0IHsgY2FtZWxpemUgfSBmcm9tICcuL2hlbHBlcnMnOwp2YXIgcGF0dGVybiA9IHsKICBzdHlsZUxpc3Q6IC87KD8hW14oXSpcKSkvZywKICBzdHlsZVByb3A6IC86KC4qKS8KfTsKCmZ1bmN0aW9uIHBhcnNlU3R5bGUoc3R5bGUpIHsKICB2YXIgc3R5bGVNYXAgPSB7fTsKCiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHN0eWxlLnNwbGl0KHBhdHRlcm4uc3R5bGVMaXN0KSksCiAgICAgIF9zdGVwOwoKICB0cnkgewogICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHsKICAgICAgdmFyIHMgPSBfc3RlcC52YWx1ZTsKCiAgICAgIHZhciBfcyRzcGxpdCA9IHMuc3BsaXQocGF0dGVybi5zdHlsZVByb3ApLAogICAgICAgICAgX3Mkc3BsaXQyID0gX3NsaWNlZFRvQXJyYXkoX3Mkc3BsaXQsIDIpLAogICAgICAgICAga2V5ID0gX3Mkc3BsaXQyWzBdLAogICAgICAgICAgdmFsID0gX3Mkc3BsaXQyWzFdOwoKICAgICAga2V5ID0ga2V5LnRyaW0oKTsKCiAgICAgIGlmICgha2V5KSB7CiAgICAgICAgY29udGludWU7CiAgICAgIH0gLy8gTWF5IGJlIHVuZGVmaW5lZCBpZiB0aGUgYGtleTogdmFsdWVgIHBhaXIgaXMgaW5jb21wbGV0ZS4KCgogICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHsKICAgICAgICB2YWwgPSB2YWwudHJpbSgpOwogICAgICB9CgogICAgICBzdHlsZU1hcFtjYW1lbGl6ZShrZXkpXSA9IHZhbDsKICAgIH0KICB9IGNhdGNoIChlcnIpIHsKICAgIF9pdGVyYXRvci5lKGVycik7CiAgfSBmaW5hbGx5IHsKICAgIF9pdGVyYXRvci5mKCk7CiAgfQoKICByZXR1cm4gc3R5bGVNYXA7Cn0KCmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlRGF0YSgpIHsKICB2YXIgbWVyZ2VUYXJnZXQgPSB7fTsKICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7CiAgdmFyIHByb3A7CiAgdmFyIGV2ZW50OyAvLyBBbGxvdyBmb3IgdmFyaWFkaWMgYXJndW1lbnQgbGVuZ3RoLgoKICB3aGlsZSAoaS0tKSB7CiAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGRhdGEgcHJvcGVydGllcyBhbmQgZXhlY3V0ZSBtZXJnZSBzdHJhdGVnaWVzCiAgICAvLyBPYmplY3Qua2V5cyBlbGltaW5hdGVzIG5lZWQgZm9yIGhhc093blByb3BlcnR5IGNhbGwKICAgIGZvciAodmFyIF9pID0gMCwgX09iamVjdCRrZXlzID0gT2JqZWN0LmtleXMoYXJndW1lbnRzW2ldKTsgX2kgPCBfT2JqZWN0JGtleXMubGVuZ3RoOyBfaSsrKSB7CiAgICAgIHByb3AgPSBfT2JqZWN0JGtleXNbX2ldOwoKICAgICAgc3dpdGNoIChwcm9wKSB7CiAgICAgICAgLy8gQXJyYXkgbWVyZ2Ugc3RyYXRlZ3kgKGFycmF5IGNvbmNhdGVuYXRpb24pCiAgICAgICAgY2FzZSAnY2xhc3MnOgogICAgICAgIGNhc2UgJ3N0eWxlJzoKICAgICAgICBjYXNlICdkaXJlY3RpdmVzJzoKICAgICAgICAgIGlmICghYXJndW1lbnRzW2ldW3Byb3BdKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQoKICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXJnZVRhcmdldFtwcm9wXSkpIHsKICAgICAgICAgICAgbWVyZ2VUYXJnZXRbcHJvcF0gPSBbXTsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAocHJvcCA9PT0gJ3N0eWxlJykgewogICAgICAgICAgICB2YXIgc3R5bGUgPSB2b2lkIDA7CgogICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbaV0uc3R5bGUpKSB7CiAgICAgICAgICAgICAgc3R5bGUgPSBhcmd1bWVudHNbaV0uc3R5bGU7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgc3R5bGUgPSBbYXJndW1lbnRzW2ldLnN0eWxlXTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdHlsZS5sZW5ndGg7IGorKykgewogICAgICAgICAgICAgIHZhciBzID0gc3R5bGVbal07CgogICAgICAgICAgICAgIGlmICh0eXBlb2YgcyA9PT0gJ3N0cmluZycpIHsKICAgICAgICAgICAgICAgIHN0eWxlW2pdID0gcGFyc2VTdHlsZShzKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGFyZ3VtZW50c1tpXS5zdHlsZSA9IHN0eWxlOwogICAgICAgICAgfSAvLyBSZXBhY2thZ2luZyBpbiBhbiBhcnJheSBhbGxvd3MgVnVlIHJ1bnRpbWUKICAgICAgICAgIC8vIHRvIG1lcmdlIGNsYXNzL3N0eWxlIGJpbmRpbmdzIHJlZ2FyZGxlc3Mgb2YgdHlwZS4KCgogICAgICAgICAgbWVyZ2VUYXJnZXRbcHJvcF0gPSBtZXJnZVRhcmdldFtwcm9wXS5jb25jYXQoYXJndW1lbnRzW2ldW3Byb3BdKTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIC8vIFNwYWNlIGRlbGltaXRlZCBzdHJpbmcgY29uY2F0ZW5hdGlvbiBzdHJhdGVneQoKICAgICAgICBjYXNlICdzdGF0aWNDbGFzcyc6CiAgICAgICAgICBpZiAoIWFyZ3VtZW50c1tpXVtwcm9wXSkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAobWVyZ2VUYXJnZXRbcHJvcF0gPT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICBtZXJnZVRhcmdldFtwcm9wXSA9ICcnOwogICAgICAgICAgfQoKICAgICAgICAgIGlmIChtZXJnZVRhcmdldFtwcm9wXSkgewogICAgICAgICAgICAvLyBOb3QgYW4gZW1wdHkgc3RyaW5nLCBzbyBjb25jYXRlbmF0ZQogICAgICAgICAgICBtZXJnZVRhcmdldFtwcm9wXSArPSAnICc7CiAgICAgICAgICB9CgogICAgICAgICAgbWVyZ2VUYXJnZXRbcHJvcF0gKz0gYXJndW1lbnRzW2ldW3Byb3BdLnRyaW0oKTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIC8vIE9iamVjdCwgdGhlIHByb3BlcnRpZXMgb2Ygd2hpY2ggdG8gbWVyZ2UgdmlhIGFycmF5IG1lcmdlIHN0cmF0ZWd5IChhcnJheSBjb25jYXRlbmF0aW9uKS4KICAgICAgICAvLyBDYWxsYmFjayBtZXJnZSBzdHJhdGVneSBtZXJnZXMgY2FsbGJhY2tzIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5LAogICAgICAgIC8vIHNvIHRoYXQgdGhlIGxhc3QgZGVmaW5lZCBjYWxsYmFjayB3aWxsIGJlIGludm9rZWQgZmlyc3QuCiAgICAgICAgLy8gVGhpcyBpcyBkb25lIHNpbmNlIHRvIG1pbWljIGhvdyBPYmplY3QuYXNzaWduIG1lcmdpbmcKICAgICAgICAvLyB1c2VzIHRoZSBsYXN0IGdpdmVuIHZhbHVlIHRvIGFzc2lnbi4KCiAgICAgICAgY2FzZSAnb24nOgogICAgICAgIGNhc2UgJ25hdGl2ZU9uJzoKICAgICAgICAgIGlmICghYXJndW1lbnRzW2ldW3Byb3BdKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQoKICAgICAgICAgIGlmICghbWVyZ2VUYXJnZXRbcHJvcF0pIHsKICAgICAgICAgICAgbWVyZ2VUYXJnZXRbcHJvcF0gPSB7fTsKICAgICAgICAgIH0KCiAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gbWVyZ2VUYXJnZXRbcHJvcF07CgogICAgICAgICAgZm9yICh2YXIgX2kyID0gMCwgX09iamVjdCRrZXlzMiA9IE9iamVjdC5rZXlzKGFyZ3VtZW50c1tpXVtwcm9wXSB8fCB7fSk7IF9pMiA8IF9PYmplY3Qka2V5czIubGVuZ3RoOyBfaTIrKykgewogICAgICAgICAgICBldmVudCA9IF9PYmplY3Qka2V5czJbX2kyXTsKCiAgICAgICAgICAgIC8vIENvbmNhdCBmdW5jdGlvbiB0byBhcnJheSBvZiBmdW5jdGlvbnMgaWYgY2FsbGJhY2sgcHJlc2VudC4KICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tldmVudF0pIHsKICAgICAgICAgICAgICAvLyBJbnNlcnQgY3VycmVudCBpdGVyYXRpb24gZGF0YSBpbiBiZWdpbm5pbmcgb2YgbWVyZ2VkIGFycmF5LgogICAgICAgICAgICAgIGxpc3RlbmVyc1tldmVudF0gPSBBcnJheSgpLmNvbmNhdCggLy8gZXNsaW50LWRpc2FibGUtbGluZQogICAgICAgICAgICAgIGxpc3RlbmVyc1tldmVudF0sIGFyZ3VtZW50c1tpXVtwcm9wXVtldmVudF0pOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIC8vIFN0cmFpZ2h0IGFzc2lnbi4KICAgICAgICAgICAgICBsaXN0ZW5lcnNbZXZlbnRdID0gYXJndW1lbnRzW2ldW3Byb3BdW2V2ZW50XTsKICAgICAgICAgICAgfQogICAgICAgICAgfQoKICAgICAgICAgIGJyZWFrOwogICAgICAgIC8vIE9iamVjdCBtZXJnZSBzdHJhdGVneQoKICAgICAgICBjYXNlICdhdHRycyc6CiAgICAgICAgY2FzZSAncHJvcHMnOgogICAgICAgIGNhc2UgJ2RvbVByb3BzJzoKICAgICAgICBjYXNlICdzY29wZWRTbG90cyc6CiAgICAgICAgY2FzZSAnc3RhdGljU3R5bGUnOgogICAgICAgIGNhc2UgJ2hvb2snOgogICAgICAgIGNhc2UgJ3RyYW5zaXRpb24nOgogICAgICAgICAgaWYgKCFhcmd1bWVudHNbaV1bcHJvcF0pIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKCFtZXJnZVRhcmdldFtwcm9wXSkgewogICAgICAgICAgICBtZXJnZVRhcmdldFtwcm9wXSA9IHt9OwogICAgICAgICAgfQoKICAgICAgICAgIG1lcmdlVGFyZ2V0W3Byb3BdID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBhcmd1bWVudHNbaV1bcHJvcF0pLCBtZXJnZVRhcmdldFtwcm9wXSk7CiAgICAgICAgICBicmVhazsKICAgICAgICAvLyBSZWFzc2lnbm1lbnQgc3RyYXRlZ3kgKG5vIG1lcmdlKQoKICAgICAgICBjYXNlICdzbG90JzoKICAgICAgICBjYXNlICdrZXknOgogICAgICAgIGNhc2UgJ3JlZic6CiAgICAgICAgY2FzZSAndGFnJzoKICAgICAgICBjYXNlICdzaG93JzoKICAgICAgICBjYXNlICdrZWVwQWxpdmUnOgogICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICBpZiAoIW1lcmdlVGFyZ2V0W3Byb3BdKSB7CiAgICAgICAgICAgIG1lcmdlVGFyZ2V0W3Byb3BdID0gYXJndW1lbnRzW2ldW3Byb3BdOwogICAgICAgICAgfQoKICAgICAgfQogICAgfQogIH0KCiAgcmV0dXJuIG1lcmdlVGFyZ2V0Owp9"},{"version":3,"sources":["../../src/util/mergeData.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAOA,SAAA,QAAA,QAAA,WAAA;AAEA,IAAM,OAAO,GAAG;AACd,EAAA,SAAS,EADK,eAAA;AAEd,EAAA,SAAS,EAAE;AAFG,CAAhB;;AAKA,SAAA,UAAA,CAAA,KAAA,EAAkC;AAChC,MAAM,QAAQ,GAAd,EAAA;;AADgC,6CAGhB,KAAK,CAAL,KAAA,CAAY,OAAO,CAAnC,SAAgB,CAHgB;AAAA;;AAAA;AAGhC,wDAAgD;AAAA,UAAhD,CAAgD;;AAAA,qBAC7B,CAAC,CAAD,KAAA,CAAQ,OAAO,CAAhC,SAAiB,CAD6B;AAAA;AAAA,UAC1C,GAD0C;AAAA,UAC1C,GAD0C;;AAE9C,MAAA,GAAG,GAAG,GAAG,CAAT,IAAM,EAAN;;AACA,UAAI,CAAJ,GAAA,EAAU;AACR;AAJ4C,OAAA,CAM9C;;;AACA,UAAI,OAAA,GAAA,KAAJ,QAAA,EAA6B;AAC3B,QAAA,GAAG,GAAG,GAAG,CAAT,IAAM,EAAN;AACD;;AACD,MAAA,QAAQ,CAAC,QAAQ,CAAjB,GAAiB,CAAT,CAAR,GAAA,GAAA;AACD;AAd+B;AAAA;AAAA;AAAA;AAAA;;AAgBhC,SAAA,QAAA;AACD;;AAQD,eAAc,SAAA,SAAA,GAAmB;AAC/B,MAAM,WAAW,GAAjB,EAAA;AACA,MAAI,CAAC,GAAW,SAAS,CAAzB,MAAA;AACA,MAAA,IAAA;AACA,MAJ+B,KAI/B,CAJ+B,CAM/B;;AACA,SAAO,CAAP,EAAA,EAAY;AACV;AACA;AACA,oCAAa,MAAM,CAAN,IAAA,CAAY,SAAS,CAAlC,CAAkC,CAArB,CAAb,kCAAwC;AAAxC,MAAA,IAAwC;;AACtC,cAAA,IAAA;AACE;AACA,aAAA,OAAA;AACA,aAAA,OAAA;AACA,aAAA,YAAA;AACE,cAAI,CAAC,SAAS,CAAT,CAAS,CAAT,CAAL,IAAK,CAAL,EAAyB;AACvB;AACD;;AACD,cAAI,CAAC,KAAK,CAAL,OAAA,CAAc,WAAW,CAA9B,IAA8B,CAAzB,CAAL,EAAuC;AACrC,YAAA,WAAW,CAAX,IAAW,CAAX,GAAA,EAAA;AACD;;AAED,cAAI,IAAI,KAAR,OAAA,EAAsB;AACpB,gBAAI,KAAJ,SAAA;;AACA,gBAAI,KAAK,CAAL,OAAA,CAAc,SAAS,CAAT,CAAS,CAAT,CAAlB,KAAI,CAAJ,EAAuC;AACrC,cAAA,KAAK,GAAG,SAAS,CAAT,CAAS,CAAT,CAAR,KAAA;AADF,aAAA,MAEO;AACL,cAAA,KAAK,GAAG,CAAC,SAAS,CAAT,CAAS,CAAT,CAAT,KAAQ,CAAR;AACD;;AACD,iBAAK,IAAI,CAAC,GAAV,CAAA,EAAgB,CAAC,GAAG,KAAK,CAAzB,MAAA,EAAkC,CAAlC,EAAA,EAAuC;AACrC,kBAAM,CAAC,GAAG,KAAK,CAAf,CAAe,CAAf;;AACA,kBAAI,OAAA,CAAA,KAAJ,QAAA,EAA2B;AACzB,gBAAA,KAAK,CAAL,CAAK,CAAL,GAAW,UAAU,CAArB,CAAqB,CAArB;AACD;AACF;;AACD,YAAA,SAAS,CAAT,CAAS,CAAT,CAAA,KAAA,GAAA,KAAA;AArBJ,WAAA,CAwBE;AACA;;;AACA,UAAA,WAAW,CAAX,IAAW,CAAX,GAAoB,WAAW,CAAX,IAAW,CAAX,CAAA,MAAA,CAAyB,SAAS,CAAT,CAAS,CAAT,CAA7C,IAA6C,CAAzB,CAApB;AACA;AACF;;AACA,aAAA,aAAA;AACE,cAAI,CAAC,SAAS,CAAT,CAAS,CAAT,CAAL,IAAK,CAAL,EAAyB;AACvB;AACD;;AACD,cAAI,WAAW,CAAX,IAAW,CAAX,KAAJ,SAAA,EAAqC;AACnC,YAAA,WAAW,CAAX,IAAW,CAAX,GAAA,EAAA;AACD;;AACD,cAAI,WAAW,CAAf,IAAe,CAAf,EAAuB;AACrB;AACA,YAAA,WAAW,CAAX,IAAW,CAAX,IAAA,GAAA;AACD;;AACD,UAAA,WAAW,CAAX,IAAW,CAAX,IAAqB,SAAS,CAAT,CAAS,CAAT,CAAA,IAAA,EAArB,IAAqB,EAArB;AACA;AACF;AACA;AACA;AACA;AACA;;AACA,aAAA,IAAA;AACA,aAAA,UAAA;AACE,cAAI,CAAC,SAAS,CAAT,CAAS,CAAT,CAAL,IAAK,CAAL,EAAyB;AACvB;AACD;;AACD,cAAI,CAAC,WAAW,CAAhB,IAAgB,CAAhB,EAAwB;AACtB,YAAA,WAAW,CAAX,IAAW,CAAX,GAAA,EAAA;AACD;;AACD,cAAM,SAAS,GAAG,WAAW,CAA7B,IAA6B,CAA7B;;AACA,4CAAc,MAAM,CAAN,IAAA,CAAY,SAAS,CAAT,CAAS,CAAT,CAAA,IAAA,KAA1B,EAAc,CAAd,qCAAqD;AAArD,YAAA,KAAqD;;AACnD;AACA,gBAAI,SAAS,CAAb,KAAa,CAAb,EAAsB;AACpB;AACA,cAAA,SAAS,CAAT,KAAS,CAAT,GAAmB,KAAK,GAAL,MAAA,EAA0B;AAC3C,cAAA,SAAS,CADQ,KACR,CADQ,EAEjB,SAAS,CAAT,CAAS,CAAT,CAAA,IAAA,EAFF,KAEE,CAFiB,CAAnB;AAFF,aAAA,MAMO;AACL;AACA,cAAA,SAAS,CAAT,KAAS,CAAT,GAAmB,SAAS,CAAT,CAAS,CAAT,CAAA,IAAA,EAAnB,KAAmB,CAAnB;AACD;AACF;;AACD;AACF;;AACA,aAAA,OAAA;AACA,aAAA,OAAA;AACA,aAAA,UAAA;AACA,aAAA,aAAA;AACA,aAAA,aAAA;AACA,aAAA,MAAA;AACA,aAAA,YAAA;AACE,cAAI,CAAC,SAAS,CAAT,CAAS,CAAT,CAAL,IAAK,CAAL,EAAyB;AACvB;AACD;;AACD,cAAI,CAAC,WAAW,CAAhB,IAAgB,CAAhB,EAAwB;AACtB,YAAA,WAAW,CAAX,IAAW,CAAX,GAAA,EAAA;AACD;;AACD,UAAA,WAAW,CAAX,IAAW,CAAX,mCAAyB,SAAS,CAAT,CAAS,CAAT,CAAL,IAAK,CAAzB,GAAgD,WAAW,CAAA,IAAA,CAA3D;AACA;AACF;;AACA,aAAA,MAAA;AACA,aAAA,KAAA;AACA,aAAA,KAAA;AACA,aAAA,KAAA;AACA,aAAA,MAAA;AACA,aAAA,WAAA;AACA;AACE,cAAI,CAAC,WAAW,CAAhB,IAAgB,CAAhB,EAAwB;AACtB,YAAA,WAAW,CAAX,IAAW,CAAX,GAAoB,SAAS,CAAT,CAAS,CAAT,CAApB,IAAoB,CAApB;AACD;;AApGL;AAsGD;AACF;;AAED,SAAA,WAAA;AACD","sourcesContent":["/**\n * @copyright 2017 Alex Regan\n * @license MIT\n * @see https://github.com/alexsasharegan/vue-functional-data-merge\n */\n/* eslint-disable max-statements */\nimport { VNodeData } from 'vue'\nimport { camelize } from './helpers'\n\nconst pattern = {\n  styleList: /;(?![^(]*\\))/g,\n  styleProp: /:(.*)/,\n} as const\n\nfunction parseStyle (style: string) {\n  const styleMap: Dictionary<any> = {}\n\n  for (const s of style.split(pattern.styleList)) {\n    let [key, val] = s.split(pattern.styleProp)\n    key = key.trim()\n    if (!key) {\n      continue\n    }\n    // May be undefined if the `key: value` pair is incomplete.\n    if (typeof val === 'string') {\n      val = val.trim()\n    }\n    styleMap[camelize(key)] = val\n  }\n\n  return styleMap\n}\n\n/**\n * Intelligently merges data for createElement.\n * Merges arguments left to right, preferring the right argument.\n * Returns new VNodeData object.\n */\nexport default function mergeData (...vNodeData: VNodeData[]): VNodeData\nexport default function mergeData (): VNodeData {\n  const mergeTarget: VNodeData & Dictionary<any> = {}\n  let i: number = arguments.length\n  let prop: string\n  let event: string\n\n  // Allow for variadic argument length.\n  while (i--) {\n    // Iterate through the data properties and execute merge strategies\n    // Object.keys eliminates need for hasOwnProperty call\n    for (prop of Object.keys(arguments[i])) {\n      switch (prop) {\n        // Array merge strategy (array concatenation)\n        case 'class':\n        case 'style':\n        case 'directives':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (!Array.isArray(mergeTarget[prop])) {\n            mergeTarget[prop] = []\n          }\n\n          if (prop === 'style') {\n            let style: any[]\n            if (Array.isArray(arguments[i].style)) {\n              style = arguments[i].style\n            } else {\n              style = [arguments[i].style]\n            }\n            for (let j = 0; j < style.length; j++) {\n              const s = style[j]\n              if (typeof s === 'string') {\n                style[j] = parseStyle(s)\n              }\n            }\n            arguments[i].style = style\n          }\n\n          // Repackaging in an array allows Vue runtime\n          // to merge class/style bindings regardless of type.\n          mergeTarget[prop] = mergeTarget[prop].concat(arguments[i][prop])\n          break\n        // Space delimited string concatenation strategy\n        case 'staticClass':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (mergeTarget[prop] === undefined) {\n            mergeTarget[prop] = ''\n          }\n          if (mergeTarget[prop]) {\n            // Not an empty string, so concatenate\n            mergeTarget[prop] += ' '\n          }\n          mergeTarget[prop] += arguments[i][prop].trim()\n          break\n        // Object, the properties of which to merge via array merge strategy (array concatenation).\n        // Callback merge strategy merges callbacks to the beginning of the array,\n        // so that the last defined callback will be invoked first.\n        // This is done since to mimic how Object.assign merging\n        // uses the last given value to assign.\n        case 'on':\n        case 'nativeOn':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {}\n          }\n          const listeners = mergeTarget[prop]!\n          for (event of Object.keys(arguments[i][prop] || {})) {\n            // Concat function to array of functions if callback present.\n            if (listeners[event]) {\n              // Insert current iteration data in beginning of merged array.\n              listeners[event] = Array<Function>().concat( // eslint-disable-line\n                listeners[event],\n                arguments[i][prop][event]\n              )\n            } else {\n              // Straight assign.\n              listeners[event] = arguments[i][prop][event]\n            }\n          }\n          break\n        // Object merge strategy\n        case 'attrs':\n        case 'props':\n        case 'domProps':\n        case 'scopedSlots':\n        case 'staticStyle':\n        case 'hook':\n        case 'transition':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {}\n          }\n          mergeTarget[prop] = { ...arguments[i][prop], ...mergeTarget[prop] }\n          break\n        // Reassignment strategy (no merge)\n        case 'slot':\n        case 'key':\n        case 'ref':\n        case 'tag':\n        case 'show':\n        case 'keepAlive':\n        default:\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = arguments[i][prop]\n          }\n      }\n    }\n  }\n\n  return mergeTarget\n}\n"],"sourceRoot":""}]}